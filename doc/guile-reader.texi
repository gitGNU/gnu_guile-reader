\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename guile-reader.info
@settitle A Reader Framework for Guile
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@set EDITION 1
@include version.texi


@ifinfo
@dircategory The Algorithmic Language Scheme
@direntry
* Guile Reader: (guile-reader).      A Reader Framework for Guile.
@end direntry

This file documents Guile Reader.

Copyright @copyright{} 2005 Ludovic Court`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title A Reader Framework for Guile
@subtitle for Guile-Reader @value{VERSION}
@author Ludovic Courtès

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@c Updated for Guile Reader @value{VERSION} @*
@value{UPDATED} @*

Copyright @copyright{} 2005 Ludovic Court`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@contents

@c *********************************************************************
@node Top, Introduction, (dir), (dir)
@top A Reader Framework for Guile

This document describes Guile-Reader version @value{VERSION}.  It was
last updated in @value{UPDATED-MONTH}.

This documentation is currently incomplete.  Details missing about the
API can very likely be found in the C header files or the C source
files.

@menu
* Introduction::                
* Overview::                    
* API Reference::               
* Internals::                   
* Concept Index::               
* Function Index::              
@end menu


@c *********************************************************************

@node Introduction, Overview, Top, Top
@chapter Introduction

Guile currently provides limited extensibility of its reader, by means
of @inforef{Reader Extensions, @code{read-hash-extend}, guile}, for
instance, or @inforef{Scheme Read, @code{read-enable}, guile}.
@uref{http://srfi.schemers.org/srfi-10/srfi-10.html, SRFI-10} tries to
propose a generic, portable, extension mechanism similar to
@code{read-hash-extend} but limited to @code{#,} sequences.  Moreover,
while this may not always be desirable, those extension facilities
have a global effect, changing the behavior of the sole reader
implementation available at run-time.  This makes it impossible to
have, for instance, one module consider names starting with @code{:}
as symbols, while another considers them as keywords.

Extensions such as the read syntax for SRFI-4 numeric vectors
(@inforef{Uniform Numeric Vectors, SRFI-4 vectors, guile}, for more
information) had to be added to Guile's built-in C reader.  Syntactic
extensions that did not appeal the majority of users, like Emacs-Lisp
vectors, are @code{#ifdef}'d within the reader code and are not
available by default.  Moreover, some extensions are incompatible with
each other, such as the DSSSL keyword syntax and the @inforef{Block
Comments, SCSH block comments, guile}.  In short the current reader
syntax is hardly extensible.

The idea of Guile Reader is to provide a framework allowing users to
quickly define readers for whatever syntax they like.  While it is
much simpler than a full-blown parser generator like Bison, its simple
programming interface should make it very straightforward to implement
readers, especially for Scheme-like syntaxes.  Best of all, Guile
Reader comes with a library of components that can typically be used
to construct a reader for the Scheme syntax.  And each one of this
components may be reused at will when creating other readers.

@cindex read table
Common Lisp has a similar mechanism to extend its reader which is
called the @dfn{read table}.  It is, however, less powerful in that it
assumes a single reader instance (which is @emph{not} a good
assumption for an interpreter).


@c chapter ----------------------------------------------------------
@node Overview, API Reference, Introduction, Top
@chapter Overview

@cindex reader
@cindex token reader
Before going into the details of the reader framework API, let us have
a quick overview of what this is.  Basically, guile-reader introduces
two objects: @dfn{readers} and @dfn{token readers}.  Readers can be
thought of, simply, as procedures like Scheme's @code{read}
@inforef{Input, R5RS, r5rs}, i.e. procedures that take one (optional)
argument, namely the port to read from.  We will see later that
readers as defined by guile-reader can actually receive two more
arguments (@pxref{Defining a New Reader}).  A reader, like
@code{read}, reads a sequence of characters (the @dfn{external
representation} of some object) and returns a Scheme object.

Token readers (TRs, for short) are the building block of a reader.  A
token reader is basically an association between a character or set of
characters and a procedure to read and interpret a sequence of
characters starting with one of the former.  For instance, in a
standard Scheme reader, the character @code{(} may be associated to a
procedure that reads an S-expression.  Likewise, lower-case and
upper-case letters associated with the appropriate procedure form a
token reader for symbols.

In guile-reader, TRs may be written either in Scheme or in C, and they
can even be a reader produced by guile-reader itself.  Unless it is a
reader, the procedure (or C function) used to create a TR will receive
four arguments:

@itemize
@item the character that was read and which triggered its call;  in
the S-exp example, this would be @code{(};
@item the port to read from;
@item the reader which performed this invocation;
@item the top-level reader which yielded this invocation.
@end itemize

The next section will provide details about the API.

@c chapter ----------------------------------------------------------
@node API Reference, Internals, Overview, Top
@chapter API Reference

All the Scheme procedures described below are exported by the
@code{(system reader)} module.  In order to be able to use them, you
will need to import this module first:

@example
(use-modules (system reader))
@end example

A C variant is also available for most of them by including the
declarations available in the @code{<guile-reader/reader.h>} header
file.

@menu
* Token Readers::               
* Readers::                     
@end menu

@node Token Readers, Readers, API Reference, API Reference
@section Token Readers

Basically, token readers are the association of a character or set of
characters and a function that is able to interpret character
sequences that start by one of these characters.  We will see below
how to define new token readers first, and then how to re-use existing
ones.

@menu
* Defining a New Token Reader::  
* TR Calling Convention::       
* Invoking a Reader from a TR::  
* Token Reader Library::        
* Token Delimiters::            
@end menu

@node Defining a New Token Reader, TR Calling Convention, Token Readers, Token Readers
@subsection Defining a New Token Reader

@cindex token reader
@cindex character specification
@findex make-token-reader

A new token reader object can be created by calling the
@code{make-token-reader} procedure with a @dfn{character
specification} and a procedure.  A character specification defines the
set of characters which should trigger an invocation of the
corresponding procedure.  The character specification may be either:

@itemize
@item a single character;
@item a pair of characters, which is interpreted as a character range;
@item a list of characters, which is interpreted as a set of
characters.
@end itemize

The procedure passed to @code{make-token-reader} may actually be
either a C function or Scheme procedure that takes four arguments
(@pxref{TR Calling Convention}), any ``object'' returned by
@code{token-reader-procedure}, or a reader.  This last option turns
out to be quite helpful.  For example, this is very convenient
when implementing the various Scheme read syntaxes prefixed by the
@code{#} character: one can create a reader for @code{#}, and then
turn it into a token reader that is part of the top-level reader.

The next section explains the token reader calling convention.


@node TR Calling Convention, Invoking a Reader from a TR, Defining a New Token Reader, Token Readers
@subsection Token Reader Calling Convention

@cindex calling convention
A token reader's procedure is passed four arguments:

@itemize
@item the character that was read and which triggered its call;  in
the S-exp example, this would be @code{(};
@item the port to read from;
@item the reader which performed this invocation, i.e. either an
@code{scm_reader_t} object (if the token reader is written in C) or a
four-argument Scheme procedure (if the token reader is written in
Scheme);
@cindex top-level reader
@item the top-level reader which yielded this invocation and which may
be different from the previous argument in the case a token reader was
made from a reader; the next section, @xref{Invoking a Reader from a
TR}, will detail the use of these two arguments.
@end itemize

It must return a Scheme object resulting from the interpretation of
the characters read.  It may as well raise an error if the input
sequence is corrupt.  Finally, it may return @code{*unspecified*}, in
which case the calling reader will not return and instead continue
reading.  This is particularly useful to define comment token readers:
a TR that has just read a comment will obviously not have any sensible
Scheme object to return, and a reader is not expected to return
anything but a ``real'' Scheme object.  A token reader for Scheme's
@code{;} line comments may be defined as follows:

@smallexample
(make-token-reader #\; read-a-line-and-return-unspecified)
@end smallexample

This behavior may, however, be overridden by passing
@code{make-token-reader} a third argument (called @var{escape?}):

@smallexample
(make-token-reader #\; read-a-line-and-return-unspecified #t)
@end smallexample

@cindex SCSH block comments
A reader that includes this TR will return @code{*unspecified*} once a
line comment has been read.  This is particularly useful, for
instance, when implementing @code{#!} block comments (@inforef{Block
Comments, SCSH block comments, guile}, for more information) as a TR
attached to @code{#\!} within the @code{#\#} sub-reader
(@pxref{Defining a New Token Reader}).

Finally, the procedure passed to @code{make-token-reader} may be
@code{#f}, in which case the resulting TR will just have the effect of
ignoring the characters it is associated to.  For instance,
handling white spaces may be done by defining a TR like this:

@smallexample
(make-token-reader '(#\space #\newline #\tab) #f)
@end smallexample

@code{make-token-reader}
FIXME:  Snarf doc from `reader.c'.

@node Invoking a Reader from a TR, Token Reader Library, TR Calling Convention, Token Readers
@subsection Invoking a Reader from a Token Reader

As seen in section @xref{Defining a New Token Reader}, token readers
are systematically passed to readers when invoked.  The reason why
this may be useful may not be obvious at first sight.

Consider an S-exp token reader.  The TR itself doesn't have sufficient
knowledge to read the objects that comprise an S-exp.  So it needs to
be able to call the reader that is being used to actually read those
objects.

The need for the @var{top-level-reader} argument passed to token
readers may be illustrated looking at the implementation of vectors
read syntax, @inforef{Vector Syntax, , guile}.  One may implement the
vector reader as a token reader of the @code{#} sub-reader
(@pxref{Defining a New Token Reader}).  The vector token reader may be
implemented like this:

@example
(lambda (chr port reader top-level-reader)
  ;; At this point, `#' as already been read and CHR is `(',
  ;; so we can directly call the regular S-expression reader
  ;; and convert its result into a vector.
  (let ((sexp-read (token-reader-procedure
                    (standard-token-reader 'sexp))))
    (apply vector
           (sexp-read chr port reader top-level-reader))))
@end example

When this procedure is invoked, @var{reader} points to the @code{#}
sub-reader.  Clearly, in order to read the symbols that comprise the
list, @var{sexp-read} should @emph{not} invoke @var{reader} because
@var{reader} only knows about @code{#}-prefixed object syntaxes.  For
this reason, in order to be consistent in re-usable, the S-exp reader
must call @var{top-level-reader} which points to the top-level reader,
i.e. the reader which yielded the invocation of the @code{#}
sub-reader.

@node Token Reader Library, Token Delimiters, Invoking a Reader from a TR, Token Readers
@subsection Token Reader Library

@cindex token reader library
Guile-reader comes with a number of re-usable token readers.
Together, they might be assembled to form a complete Scheme reader
equivalent to that of Guile (@pxref{Reader Library}).  Or they can be
used individually in any reader.

The @code{standard-token-reader} procedure takes a symbol that names a
standard TR from the library and returns it (or @code{#f} if not
found).  Currently, the available TRs are:

@c Include the documentation that was generated using `extract-doc.scm'.
@include token-reader-doc.texi

As can be inferred from the above two lists, reading character
sequences starting with the @code{#} characters can easily be done by
defining a sub-reader for that character.  That reader can then be
passed to @code{make-token-reader} as the procedure attached to
@code{#}:

@example
(define sharp-reader
  (make-reader (map standard-token-reader
                    '(boolean character
                      number+radix keyword
                      srfi-4
                      block-comment))))

(define top-level-reader
  (make-reader (list (make-token-reader #\# sharp-reader)
                     ...
                     )))
@end example

FIXME:  Snarf doc from `reader.c'.
@code{standard-token-reader}

@code{token-reader-specification}
@code{token-reader-procedure}
@code{token-reader-escape?}


@node Token Delimiters,  , Token Reader Library, Token Readers
@subsection Token Delimiters

@cindex token delimiters
As can be seen from the previous section, there exist, for instance,
an surprisingly high number of symbol token readers.  The reason for
this is that different syntax variants define different @dfn{token
delimiters}.  Token delimiters are characters that help the reader
determine where tokens that require implicit termination do
terminate.  Quoting R5RS (@inforef{Lexical structure, R5RS' lexical
structure, r5rs}, for details):

@quotation
Tokens which require implicit termination (identifiers, numbers,
characters, and dot) may be terminated by any <delimiter>, but not
necessarily by anything else.
@end quotation

@cindex R5RS
@cindex R6RS
R5RS defines token delimiters as one of the following: a whitespace, a
parentheses, a quotation mark (@code{"}) or a semi-colon (@code{;})
character.  On the other hand, R6RS, which is to support the ability
to use square brackets instead of parentheses for S-expressions, also
considers square brackets as token delimiters.  Likewise, if we were
to support curly braces to enclose S-expressions, then curly braces
would need to be considered as token delimiters too.

For this reason, the token reader library comes with several symbol
token readers: the @code{guile-symbol-} family does not consider
square brackets as delimiters while the @code{r6rs-symbol-} family
does, the @code{brace-free-} TR family considers curly braces as
delimiters but not square brackets, etc.  Similarly, several variants
of number TRs are available.  This is due to the fact that number TRs
may return symbols in corner cases like symbol names starting with a
number.

However, although keywords must also comply with the token delimiters
rules, there is only one keyword TR (called @code{keyword}).  The
reason for this is that this TR relies on the top-level reader's
symbol reader to read the symbol that makes up the keyword being read.

@cindex pitfall
In the current design of guile-reader, this token delimiter issue
creates a number of pitfalls when one is willing to change the current
delimiters.  In particular, one has to be very careful about using TRs
that consistently assume the same token delimiters.


@node Readers,  , Token Readers, API Reference
@section Readers

Guile-reader is about defining readers.  Continuing to read this
manual was definitely a good idea since we have finally reached the
point where we will start talking about how to define new readers.

@menu
* Defining a New Reader::       
* Reader Library::              
* Compatibility and Confinement::  
@end menu

@node Defining a New Reader, Reader Library, Readers, Readers
@subsection Defining a New Reader

@cindex reader
Roughly, a reader is no more than a loop which reads characters from a
given port, and dispatches further interpretation to more specific
procedures.  Written in Scheme, it could resemble something like:

@lisp
(define (my-reader port)
  (let loop ((result *unspecified*))
    (let ((the-char (getc port)))
      (case the-char
        ((#\()  (my-sexp-token-reader the-char port my-reader)))
        ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
         (my-number-token-reader the-char port my-reader))
        (else
         (error "unexpected character" the-char))))))
@end lisp

@findex make-reader
Using guile-reader, this is done simply by providing a list of token
readers to the @code{make-reader} procedure, as in the following
example:

@lisp
(define my-reader
  (make-reader (list (make-token-reader #\( my-sexp-token-reader)
                     (make-token-reader '(#\0 . #\9)
                                        my-number-token-reader))))
@end lisp

However, the procedure returned by @code{make-reader} is different
from the hand-written one above in that in takes two additional
optional arguments which makes it look like this:

@lisp
(define (my-reader port faults-caller-handled? top-level-reader)
  (let loop ((the-char (getc port)))
    (case the-char
      ...
      (else
        (if (not faults-caller-handled?)
            (error "unexpected character" the-char)
            (ungetc the-char) ;; and return *unspecified*
            )))))
@end lisp

Therefore, by default, @code{my-reader} will raise an error as soon as
it reads a character that it does not know how to handle.  However, if
the caller passes @code{#t} as its @code{faults-caller-handled?}
argument, then @code{my-reader} is expected to ``unget'' the faulty
character and return @code{*unspecified*}, thus allowing the caller to
handle the situation.

This is useful, for instance, in the S-exp token reader example: the
S-exp token reader needs to call its calling reader in order to read
the components between the opening and closing brackets;  however, the
calling reader may be unable to handle the @code{#\)} character so the
S-exp token reader has to handle it by itself and needs to tell it to
the reader.

@code{make-reader}
FIXME:  Snarf doc from `reader.c'.

Currently, the flags that may be passed to token readers are the
following:

@itemize

@item @code{reader/record-positions} will yield a reader that records
the position of the expression read, which is mostly useful for
debugging purposes; this information may then be accessed via source
properties @inforef{Procedure Properties, source properties, guile}.

@item @code{reader/lower-case} will have the yielded reader convert to
lower-case all the letters that it reads; note that this is not
sufficient to implement symbol case-insensitivity as shown
@inforef{Reader options, here, guile}.  For this, the token reader(s)
that read symbols must also convert all subsequent characters to
lower-case.

@item @code{reader/upper-case} will have the yielded reader convert to
upper-case all the letters that it reads; again, that is not
sufficient to implement case-insensitivity.

@item @code{reader/debug} causes the generated reader to produce
debugging output.

@end itemize

@node Reader Library, Compatibility and Confinement, Defining a New Reader, Readers
@subsection Reader Library

@cindex reader library
The @code{(system reader)} module exports the @code{default-reader}
procedure which returns a reader equivalent to Guile's built-in
default reader made of re-usable token readers written in C
(@pxref{Token Reader Library}).

@itemize
@item @code{default-reader}
@item @code{default-reader-token-readers}
@item @code{default-sharp-reader-token-readers}
@end itemize

FIXME:  Snarf doc from `reader-lib.c'.

Additionally, the @code{(system reader library)} module exports a
number of procedures that ease the re-use of readers.

@include reader-lib-doc.texi


@node Compatibility and Confinement,  , Reader Library, Readers
@subsection Compatibility and Confinement

@findex read-options
@findex read-enable
@findex read-disable
@findex read-set!
@findex read-hash-extend
Guile's core read subsystem (@inforef{Scheme Read, , guile}, for
details) provides an interface to customize its reader, namely via the
@code{read-options} (@inforef{Reader Options, Guile's built-in reader
option, guile}, for more information) and @code{read-hash-extend}
(@inforef{Reader Extensions, @code{read-hash-extend}, guile}, for
details) procedures.

The main problem with this approach is that changing the reader's
options using these procedures has a global effect since there is only
one instance of @code{read}.  Changing the behavior of a single
function at the scale of the whole is not very ``schemey'' and can be
quite harmful. Suppose a module relies on case-insensitivity while
another relies on case-sensitivity.  If one tries to use both modules
at the same time, chances are that at least one of them will not work
as expected.  Risks of conflicts are even higher when
@code{read-hash-extend} is used: imagine a module that uses
DSSSL-style keywords, while another needs SCSH-style block comments.

@cindex confinement
@cindex reader confinement
@cindex compatibility
@findex read-options-interface
In @code{(system reader confinement)}, guile-reader offers an
implementation of @code{read-option-interface} and
@code{read-hash-extend} that allows to @emph{confine} such settings on
a per-module basis.  In order to enable reader confinement, one just
has to do this:

@smalllisp
(use-modules (system reader confinement))
@end smalllisp

Note that this must be done before the suspicious modules are loaded,
that is, typically when your program starts.  This will redefine
@code{read-options-interface} and @code{read-hash-extend} so that any
future modification performed via Guile's built-in reader option
interface will be confined to the calling module.

@findex current-reader
Starting from Guile 1.7.3, @code{current-reader} is a core binding
bound to a fluid whose value should be either `#f' or a reader (i.e.,
a @code{read}-like procedure).  The value of this fluid dictates the
reader that is to be used by @code{primitive-load} and its value can
be changed dynamically.

The confined variants of @code{read-options-interface} and
@code{read-hash-extend} rely on this feature to make reader
customizations local to the file being loaded.  This way, invocations
of these functions from within a file being loaded by
@code{primitive-load} take effect immediately.

@cindex forward-compatibility
When using a version of Guile that does not support the
@code{current-reader} feature, the @code{(system reader compat)}
module defines a new @code{current-reader} core binding and redefines
@code{primitive-load} in order to provide compatibility with newer
versions of Guile.


@c chapter ----------------------------------------------------------
@node Internals, Concept Index, API Reference, Top
@chapter Internals

In order to not have to trade too much performance for flexibility,
guile-reader dynamically compiles code for the readers defined using
GNU Lightning @inforef{Overview, Introduction to GNU Lightning,
lightning}.  As of version 1.2, GNU Lightning can generate code for
the PowerPC, SPARC, and IA32 architectures.  For other platforms,
guile-reader provides an alternative (slower) implementation that does
not depend on it.

Re-using token readers written in C, as explained in @xref{Token
Reader Library}, does not imply any additional cost: the underlying C
function will be called directly by the reader, without having to go
through any marshalling/unmarshalling stage.

@findex make-guile-reader
Additionally, on the C side, token readers may be initialized
@emph{statically} (except, obviously, token readers made out of a
dynamically-compiled reader).  Making good use of it can improve the
startup time of a program.  For example, @code{make-guile-reader}
(@pxref{Reader Library}) is implemented in C and it uses statically
initialized arrays of token readers.  It still needs to invoke
@code{scm_c_make_reader ()}, but at least, token readers themselves
are ``ready to use''.


@c *********************************************************************
@node Concept Index, Function Index, Internals, Top
@unnumbered Concept Index
@printindex cp

@node Function Index,  , Concept Index, Top
@unnumbered Function Index
@printindex fn


@bye

@ignore
;;; arch-tag: e82c9dff-b040-4398-a1e9-1e2570cfc025
@end ignore

@c Local Variables:
@c ispell-local-dictionary: "american"
@c End:
