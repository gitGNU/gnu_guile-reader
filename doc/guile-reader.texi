\input texinfo  @c -*-texinfo-*-

@c %**start of header
@setfilename guile-reader.info
@settitle Guile's Reader Framework
@footnotestyle end
@setchapternewpage odd
@c %**end of header

@set EDITION 1
@set VERSION 0.2
@c @set UPDATED 2005-04-26


@ifinfo
@dircategory The Algorithmic Language Scheme
@direntry
* Guile Reader: (guile-reader).      Guile's Reader Framework.
@end direntry

This file documents Guile Reader.

Copyright @copyright{} 2005 Ludovic Court`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end ifinfo

@titlepage
@title Guile's Reader Framework
@subtitle for Guile-Reader @value{VERSION}
@author Ludovic Courtès

@page
@vskip 0pt plus 1filll
Edition @value{EDITION} @*
@c Updated for Guile Reader @value{VERSION} @*
@value{UPDATED} @*

Copyright @copyright{} 2005 Ludovic Court`es

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation
approved by the Free Software Foundation.
@end titlepage

@contents

@c *********************************************************************
@node Top, Introduction, (dir), (dir)
@top Guile's Reader Framework

This document describes Guile-Reader version @value{VERSION}.

This documentation is currently incomplete.  Details missing about the
API can very likely be found in the C header files or the C source
files.

@menu
* Introduction::                
* Overview::                    
* API Reference::               
* Internals::                   
@end menu


@c *********************************************************************

@node Introduction, Overview, Top, Top
@chapter Introduction

Guile currently provides limited extensibility of its reader, by means
of @inforef{Reader Extensions, @code{read-hash-extend}, guile}, for
instance, or @inforef{Scheme Read, @code{read-enable}, guile}.
@uref{http://srfi.schemers.org/srfi-10/srfi-10.html, SRFI-10} tries to
propose a generic, portable, extension mechanism similar to
@code{read-hash-extend} but limited to @code{#,} sequences.  Moreover,
while this may not always be desirable, those extension facilities
have a global effect, changing the behavior of the sole reader
implementation available at run-time.  This makes it impossible to
have, for instance, one module consider names starting with @code{:}
as symbols, while another considers them as keywords.

Extensions such as the read syntax for SRFI-4 numeric vectors
(@inforef{Uniform Numeric Vectors, SRFI-4 vectors, guile}, for more
information) had to be added to Guile's built-in C reader.  Syntactic
extensions that did not appeal the majority of users, like Emacs-Lisp
vectors, are @code{#ifdef}'d within the reader code and are not
available by default.  Moreover, some extensions are incompatible with
each other, such as the DSSSL keyword syntax and the @inforef{Block
Comments, SCSH block comments, guile}.  In short the current reader
syntax is hardly extensible.

The idea of Guile Reader is to provide a framework allowing users to
quickly define readers for whatever syntax they like.  While it is
much simpler than a full-blown parser generator like Bison, its simple
programming interface should make it very straightforward to implement
readers, especially for Scheme-like syntaxes.  Best of all, Guile
Reader comes with a library of components that can typically be used
to construct a reader for the Scheme syntax.  And each one of this
components may be reused at will when creating other readers.

Note that Common Lisp has a similar mechanism, the @dfn{read table}.
It is, however, less powerful in that it assumes a single reader
instance (which is @emph{not} a good assumption for an interpreter).



@node Overview, API Reference, Introduction, Top
@chapter Overview

Before going into the details of the reader framework API, let us have
a quick overview of what this is.  Basically, guile-reader introduces
two objects: @dfn{readers} and @dfn{token readers}.  Readers can be
thought of, simply, as procedures like Scheme's @code{read}
@inforef{Input, R5RS, r5rs}, i.e. procedures that take one (optional)
argument, namely the port to read from.  We will see later that
readers as defined by guile-reader can actually receive a second
argument (FIXME: xref).  A reader, like @code{read}, reads a sequence
of characters (the @dfn{external representation} of some object) and
returns a Scheme object.

Token readers (TRs, for short) are the building block of a reader.  A
token reader is basically an association between a character or set of
characters and a procedure to read and interpret a sequence of
characters starting with one of the former.  For instance, in a
standard Scheme reader, the character @code{(} may be associated to a
procedure that reads an S-expression.  Likewise, lower-case and
upper-case letters associated with the appropriate procedure form a
token reader for symbols.

In guile-reader, TRs may be written either in Scheme or in C, and they
can even be a reader produced by guile-reader itself.  Unless it is a
reader, the procedure (or C function) used to create a TR will receive
four arguments:

@itemize
@item the character that was read and which triggered its call;  in
the S-exp example, this would be @code{(};
@item the port to read from;
@item the reader which performed this invocation;
@item the top-level reader which yielded this invocation.
@end itemize

The next section will provide details about the API.


@node API Reference, Internals, Overview, Top
@chapter API Reference

All the Scheme procedures described below are exported by the
@code{(system reader)} module.  In order to be able to use them, you
will need to import this module first:

@example
(use-modules (system reader))
@end example

A C variant is also available for most of them by including the
declarations available in the @code{<guile-reader/reader.h>} header
file.

@menu
* Token Readers::               
* Readers::                     
@end menu

@node Token Readers, Readers, API Reference, API Reference
@section Token Readers

Basically, token readers are the association of a character or set of
characters and a function that is able to interpret character
sequences that start by one of these characters.  We will see below
how to define new token readers first, and then how to re-use existing
ones.

@menu
* Defining a New Token Reader::  
* TR Calling Convention::       
* Invoking a Reader from a TR::  
* Token Reader Library::        
@end menu

@node Defining a New Token Reader, TR Calling Convention, Token Readers, Token Readers
@subsection Defining a New Token Reader

A new token reader object can be created by calling the
@code{make-token-reader} procedure with a @dfn{character
specification} and a procedure.  A character specification defines the
set of characters which should trigger an invocation of the
corresponding procedure.  The character specification may be either:

@itemize
@item a single character;
@item a pair of characters, which is interpreted as a character range;
@item a list of characters, which is interpreted as a set of
characters.
@end itemize

The procedure passed to @var{make-token-reader} may actually be either
a C function or Scheme procedure that takes four arguments (@pxref{TR
Calling Convention}), any ``object'' returned by
@code{token-reader-procedure}, or a reader.  This last option turns
out to be quite helpful.  For example, this turns out to be convenient
when implementing the various Scheme read syntaxes prefixed by the
@code{#} character: one can create a reader for @code{#}, and then
turn it into a token reader that is part of the top-level reader.

The next section explains the token reader calling convention.


@node TR Calling Convention, Invoking a Reader from a TR, Defining a New Token Reader, Token Readers
@subsection Token Reader Calling Convention

A token reader's procedure is passed four arguments:

@itemize
@item the character that was read and which triggered its call;  in
the S-exp example, this would be @code{(};
@item the port to read from;
@item the reader which performed this invocation, i.e. either an
@code{scm_reader_t} object (if the token reader is written in C) or a
four-argument Scheme procedure (if the token reader is written in
Scheme);
@item the top-level reader which yielded this invocation and which may
be different from the previous argument in the case a token reader was
made from a reader; the next section, @xref{Invoking a Reader from a
TR}, will detail the use of these two arguments.
@end itemize

It must return a Scheme object resulting from the interpretation of
the characters read.  It may as well raise an error if the input
sequence is corrupt.  Finally, it may return @code{*unspecified*}, in
which case the calling reader will not return and instead continue
reading.  This is particularly useful to define comment token readers:
a TR that has just read a comment will obviously not have any sensible
Scheme object to return, and a reader is not expected to return
anything but a ``real'' Scheme object.  A token reader for Scheme's
@code{;} line comments may be defined as follows:

@example
(make-token-reader #\; read-a-line-and-return-unspecified)
@end example

This behavior may, however, be overridden by passing
@code{make-token-reader} a third argument (called @var{escape?}):

@example
(make-token-reader #\; read-a-line-and-return-unspecified #t)
@end example

A reader that includes this TR will return @code{*unspecified*} once a
line comment has been read.  This is particularly useful, for
instance, when implementing @code{#!} block comments (@inforef{Block
Comments, SCSH block comments, guile}, for more information) as a TR
attached to @code{#\!} within the @code{#\#} sub-reader
(@pxref{Defining a New Token Reader}).

Finally, the procedure passed to @code{make-token-reader} may be
@code{#f}, in which case the resulting TR will just have the effect of
ignoring the characters it is associated to.  For instance,
handling white spaces may be done by defining a TR like this:

@example
(make-token-reader '(#\space #\newline #\tab) #f)
@end example

@code{make-token-reader}
FIXME:  Snarf doc from `reader.c'.

@node Invoking a Reader from a TR, Token Reader Library, TR Calling Convention, Token Readers
@subsection Invoking a Reader from a Token Reader

As seen in section @xref{Defining a New Token Reader}, token readers
are systematically passed to readers when invoked.  The reason why
this may be useful may not be obvious at first sight.

Consider an S-exp token reader.  The TR itself doesn't have sufficient
knowledge to read the objects that comprise an S-exp.  So it needs to
be able to call the reader that is being used to actually read those
objects.

The need for the @var{top-level-reader} argument passed to token
readers may be illustrated looking at the implementation of vectors
read syntax, @inforef{Vector Syntax, , guile}.  One may implement the
vector reader as a token reader of the @code{#} sub-reader
(@pxref{Defining a New Token Reader}).  The vector token reader may be
implemented like this:

@example
(lambda (chr port reader top-level-reader)
  ;; At this point, `#' as already been read and CHR is `(',
  ;; so we can directly call the regular S-expression reader
  ;; and convert its result into a vector.
  (let ((sexp-read (token-reader-procedure
                    (standard-token-reader 'sexp))))
    (apply vector
           (sexp-read chr port reader top-level-reader))))
@end example

When this procedure is invoked, @var{reader} points to the @code{#}
sub-reader.  Clearly, in order to read the symbols that comprise the
list, @var{sexp-read} should @emph{not} invoke @var{reader} because
@var{reader} only knows about @code{#}-prefixed object syntaxes.  For
this reason, in order to be consistent in re-usable, the S-exp reader
must call @var{top-level-reader} which points to the top-level reader,
i.e. the reader which yielded the invocation of the @code{#}
sub-reader.

@node Token Reader Library,  , Invoking a Reader from a TR, Token Readers
@subsection Token Reader Library

Guile-reader comes with a number of re-usable token readers.
Together, they might be assembled to form a complete Scheme reader
equivalent to that of Guile (@pxref{Reader Library}).  Or they can be
used individually in any reader.

The @code{standard-token-reader} procedure takes a symbol that names a
standard TR from the library and returns it (or @code{#f} if not
found).  Currently, the available TRs are:

@c Include the documentation that was generated using `extract-doc.scm'.
@table @code
@include token-reader-doc.texi
@end table

As can be inferred from the above two lists, reading character
sequences starting with the @code{#} characters can easily be done by
defining a sub-reader for that character.  That reader can then be
passed to @code{make-token-reader} as the procedure attached to
@code{#}:

@example
(define sharp-reader
  (make-reader (map standard-token-reader
                    '(boolean character
                      number+radix keyword
                      srfi-4
                      block-comment))))

(define top-level-reader
  (make-reader (list (make-token-reader #\# sharp-reader)
                     ...
                     )))
@end example

FIXME:  Snarf doc from `reader.c'.
@code{standard-token-reader}

@code{token-reader-specification}
@code{token-reader-procedure}
@code{token-reader-escape?}

@node Readers,  , Token Readers, API Reference
@section Readers

Guile-reader is about defining readers.  Continuing to read was
definitely a good idea since we have finally reached the point where
we will start talking about how to define new readers.

@menu
* Defining a New Reader::       
* Reader Library::              
@end menu

@node Defining a New Reader, Reader Library, Readers, Readers
@subsection Defining a New Reader

Roughly, a reader is no more than a loop which reads characters from a
given port, and dispatches further interpretation to more specific
procedures.  Written in Scheme, it could resemble something like:

@example
(define (my-reader port)
  (let loop ((result *unspecified*))
    (let ((the-char (getc port)))
      (case the-char
        ((#\()  (my-sexp-token-reader the-char port my-reader)))
        ((#\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9)
         (my-number-token-reader the-char port my-reader))
        (else
         (error "unexpected character" the-char))))))
@end example

Using guile-reader, this is done simply by providing a list of token
readers to the @code{make-reader} procedure, as in the following
example:

@example
(define my-reader
  (make-reader (list (make-token-reader #\( my-sexp-token-reader)
                     (make-token-reader '(#\0 . #\9)
                                        my-number-token-reader))))
@end example

However, the procedure returned by @code{make-reader} is different
from the hand-written one above in that in takes two additional
optional arguments which makes it look like this:

@example
(define (my-reader port faults-caller-handled? top-level-reader)
  (let loop ((the-char (getc port)))
    (case the-char
      ...
      (else
        (if (not faults-caller-handled?)
            (error "unexpected character" the-char)
            (ungetc the-char) ;; and return *unspecified*
            )))))
@end example

Therefore, by default, @code{my-reader} will raise an error as soon as
it reads a character that it does not know how to handle.  However, if
the caller passes @code{#t} as its @code{faults-caller-handled?}
argument, then @code{my-reader} is expected to ``unget'' the faulty
character and return @code{*unspecified*}, thus allowing the caller to
handle the situation.

This is useful, for instance, in the S-exp token reader example: the
S-exp token reader needs to call its calling reader in order to read
the components between the opening and closing brackets;  however, the
calling reader may be unable to handle the @code{#\)} character so the
S-exp token reader has to handle it by itself and needs to tell it to
the reader.

@code{make-reader}
FIXME:  Snarf doc from `reader.c'.

Currently, the flags that may be passed to token readers are the
following:

@itemize

@item @code{reader/record-positions} will yield a reader that records
the position of the expression read, which is mostly useful for
debugging purposes; this information may then be accessed via source
properties @inforef{Procedure Properties, source properties, guile}.

@item @code{reader/lower-case} will have the yielded reader convert to
lower-case all the letters that it reads; note that this is not
sufficient to implement symbol case-insensitivity as shown
@inforef{Reader options, here, guile}.  For this, the token reader(s)
that read symbols must also convert all subsequent characters to
lower-case.

@item @code{reader/upper-case} will have the yielded reader convert to
upper-case all the letters that it reads; again, that is not
sufficient to implement case-insensitivity.

@item @code{reader/debug} causes the generated reader to produce
debugging output.

@end itemize

@node Reader Library,  , Defining a New Reader, Readers
@subsection Reader Library

The @code{(system reader)} module exports the @code{default-reader}
procedure which returns a reader equivalent to Guile's built-in
default reader made of re-usable token readers written in C
(@pxref{Token Reader Library}).

@code{default-reader}

@code{default-reader-token-readers}

@code{default-sharp-reader-token-readers}

FIXME:  Snarf doc from `reader.c'.


@node Internals,  , API Reference, Top
@chapter Internals

In order to not have to trade too much performance for flexibility,
guile-reader dynamically compiles code for the readers defined using
GNU Lightning @inforef{Overview, Introduction to GNU Lightning,
lightning}.  As of version 1.2, GNU Lightning can generate code for
the PowerPC, SPARC, and IA32 architectures.  For other platforms,
guile-reader provides an alternative (slower) implementation that does
not depend on it.

Re-using token readers written in C, as explained in @xref{Token
Reader Library}, does not imply any additional cost: the underlying C
function will be called directly by the reader, without having to go
through any marshalling/unmarshalling stage.


@c *********************************************************************
@c @node Concept Index, Command Index, Related Information, Top
@c @unnumbered Concept Index
@c @printindex cp

@c @node Command Index, Variable Index, Concept Index, Top
@c @unnumbered Command Index
@c @printindex fn

@c @node Variable Index,  , Command Index, Top
@c @unnumbered Variable Index
@c @printindex vr

@bye


@ignore
;;; arch-tag: e82c9dff-b040-4398-a1e9-1e2570cfc025
@end ignore

@c Local Variables:
@c mode:outline-minor
@c outline-regexp:"@\\(ch\\|sec\\|subs\\)"
@c End:
